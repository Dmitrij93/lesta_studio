# Задание на Junior Python Programmer в Lesta Studio

Привет! задания 1 и 2 описаны комментариями. Задание 3 требует разъяснений. Каждый алгоритм сортировки хорош только в конкретных условиях.

Быстрая сортировка на больших данных будет показывать сложность близко к O(N*log(N)), но ещё должно повезти с опорным элементом.

Сортировка слиянием даёт сложность O(N*log(N)), но использует O(N) дополнительной памяти. Оба алгоритма можно было бы распараллелить, но с Global Interpreter Lock в Python параллельность частенько звучит как шутка. Ещё есть десятки других сортировок.

Сортировка в Python комбинированная и ведёт себя по разному на разных объёмах данных. Сложность O(N*log(N)).

Вообще их десятки, но есть и особые случаи, когда алгоритмы могут кардинально отличаться:

Пусть мы знаем, что в наших данных очень мало уникальных значений. Тогда мы можем построить словарь частот, отсортировать ключи и вывести последовательно эти ключи по числу их встречаний. Сложность по скорости будет близка к O(N) и потребует O(M) дополнительнй памяти, M много меньше N.

Ещё вариант, когда сортировка в привычном смысле проигрывает - длинный список неотсортированных троек. Такие тройки лучше прогонять через три сравнения.

Таким образом, чтобы решение вашей задачи имело смысл, нужно предоставить больше данных.

# coding=utf-8

import timeit


# исходный вариант, выполняет деление, операция должна быть медленной, правда в
# python это в глаза не бросается, так как его цель - быстрая и удобная
# разработка больших проектов, что поддерживается невероятным числом библиотек.
# Разница заметна при изменении сложности алгоритмов
def isEven(value):
    return value % 2 == 0


# другой подход - смотреть только на младший бит, если пустой - значит число
# четное можно проверять на равенство, можно воспользоваться неявным приведением
# типа к bool и отрицание нуля даст истину. В С/С++ операция будет быстрее.
def isEvenMy(value):
    return not value & 1


# ещё подход - сдвинуть число как поток бит на 1 влево, потом на 1 вправо. Число
# разделилось на 2, не сохранив остаток, после умножилось на 2. Если число было
# четным, то оно не теряло остаток и после умножения не уменьшилось, осталось
# прежним. В теории операция также быстрее целочисленного деления
def isEvenMy2(value):
    return value >> 1 << 1 == value


x = 2374374783


def main():
    print(timeit.timeit("isEven(x)", setup="from __main__ import isEven, x",
                        number=1))
    print(timeit.timeit("isEvenMy(x)", setup="from __main__ import isEvenMy, x",
                        number=1))
    print(
        timeit.timeit("isEvenMy2(x)", setup="from __main__ import isEvenMy2, x",
                      number=1))


main()
